<!DOCTYPE html>
<html>
<head>
<style>
	body {
		background-color: #fff;
		color: #111;
		margin: 0px;
		overflow: hidden;
		font-family: Monospace;
		font-size: 30px;
		position: absolute;
	}
</style>
</head>

<body>

<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/origami.js"></script>
<script src="js/state.js"></script>
<script src="js/stage.js"></script>
<script src="js/geometry.js"></script>
<script src="js/fold.js"></script>
<script src="js/facegroup.js"></script>
<script src="js/face.js"></script>
<script src="js/edge.js"></script>
<script src="js/vector.js"></script>
<script src="js/vertex.js"></script>
<script src="js/KeyboardState.js"></script>
<script src="js/return.js"></script>
<script src="js/adjust.js"></script>
<script src="js/dat.gui.min.js"></script>
<script src="js/localStorage.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2014-11-29/FileSaver.min.js"></script>

<script id="myVertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        vUv = uv;
    }
</script>
<script id="myFragmentShader" type="x-shader/x-fragment">
    varying vec2 vUv;
    uniform vec3 front;
    uniform vec3 back;
    uniform float n;
    uniform sampler2D tex;

    void main() {
        vec3 color;

        if (n > 0.0){
            color = texture2D(tex, vUv).rgb;
        }
        else{
            color = back;
        }
        gl_FragColor = vec4(color, 1.0);
    }
</script>

<script>

var camera, scene, renderer, control;
var keyboard = new KeyboardState();
var eyePosition = new Vector();
var objects = [];
var cnt = 0;
var mouseDown = false;
var str = "";

//face texture
var texture, fc, bc;

var Origami = new Origami();
var State = new State();
var Cursor3D = new cursor3D();
var KState = new KState();

//define
var DBL_MAX = 10000000;
var DBL_EPSILON = 2.2204460492503131e-16;

init();
animate();

function init() {
	renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor (0x888888);

    document.body.appendChild(renderer.domElement);
	
    scene = new THREE.Scene();

	//camera
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 50;
    camera.lookAt (new THREE.Vector3 (0,0,0));
    scene.add(camera);

    eyePosition.set (camera.position.x, camera.position.y, camera.position.z);

    //control
    control = new THREE.OrbitControls(camera, renderer.domElement);

    //face texture
    fc = new THREE.Color(0xff0000);
    bc = new THREE.Color(0xffffff);

    THREE.ImageUtils.crossOrigin = '';
    texture = THREE.ImageUtils.loadTexture('image/tex1.png');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
	
	Origami.setOriginal();
    display();
    
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
}

function display(){
    Origami.draw (eyePosition);
    Origami.drawAdjust();
    //console.log ('display');
}

function resetScene(){
    var i;
    for (i = 0; i < objects.length; i++){
        scene.remove(objects[i]);
        delete objects[i];
    }
}

function lightVertex(pos)
{
    var vertex = new THREE.Mesh (new THREE.CylinderGeometry(.3,.3,.1,32),
        new THREE.MeshBasicMaterial({color:0xffff00}));
    vertex.rotation.x = Math.PI/2;
    vertex.position.set(pos.x, pos.y, pos.z);

    scene.add (vertex); 
    objects.push(vertex);

    //console.log ('light');
}

function onMouseDown(event){
    if (State.inAnimation || State.inRotation)
        return;
    if (event.button == 2){
        resetScene();
        display();
        return;
    }

    var vector = new THREE.Vector3();
    vector.set(
        ( event.clientX / window.innerWidth ) * 2 - 1,
        - ( event.clientY / window.innerHeight ) * 2 + 1,
        0.5 );
    vector.unproject( camera );
    var dir = vector.sub( camera.position ).normalize();
    var distance = - camera.position.z / dir.z;
    var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );

    if (State.inBending){
        Cursor3D.x = pos.x;
        Cursor3D.y = pos.y;
    }
    else
        Cursor3D.set (pos.x, pos.y, pos.z);
    //console.log (Cursor3D.x+" "+Cursor3D.y+" "+Cursor3D.z);

    var p = new Vector(pos.x, pos.y, pos.z);
    var v = new Vector(Cursor3D.x, Cursor3D.y, Cursor3D.z);
    var picked = new Vector();
    picked.set2(Origami.pickVertex(v));
    //console.log (picked);

    if (picked.distance(p) <= 0.5){
        State.inFolding = true;
        resetScene();
        display();
    }
}

function onDocumentMouseDown(event)
{
    mouseDown = true;
    onMouseDown(event);
}

function onDocumentMouseUp(event){
    mouseDown = false;

    Origami.releaseVertex();
    State.inFolding = false;

    resetScene();
    display();
}

function onDocumentMouseMove(event){
    if (mouseDown)
        onMouseDown(event);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
	
	update();
    render();
}

function keyBoard(){
    if (keyboard.down('Z')){
        Origami.reset();
        resetScene();
        display();
    }
    if (keyboard.down('I')){
        Origami.reset2(0);
        resetScene();
        display();
    }
    if (keyboard.down('A')){
        if (!State.inFolding && !State.inAnimation){
            clearlog();
            Origami.save();
            Origami.reset2(0);
            Origami.animation.position = -1.0;
            State.inAnimation = true;
            Origami.animation.step = 0;
        }
        else {
            Origami.load();
            State.inAnimation = false;
        }
        resetScene();
        display();
    }
    if (keyboard.down('M')){
        KState.M = true;
        resetScene();
        display();
    }
    if (keyboard.up('M')){
        KState.M = false;
        resetScene();
        display();
    }
    if (keyboard.down('N')){
        KState.N = true;
        resetScene();
        display();
    }
    if (keyboard.up('N')){
        KState.N = false;
        resetScene();
        display();
    }
    if (keyboard.down('T')){
        KState.T = true;
        resetScene();
        display();
    }
    if (keyboard.up('T')){
        KState.T = false;
        resetScene();
        display();
    }
    if (keyboard.down('S')){
        Origami.save();
        saveTXT();
    }
}

function update() 
{
    control.update();
    keyboard.update();

    keyBoard();
    eyePosition.set (camera.position.x, camera.position.y, camera.position.z);
    
    timer();

    /*
    cnt = 0;
    scene.traverse( function( child ) {
    if( child instanceof THREE.Mesh )
        cnt++;
    } );
    console.log (cnt);
    */
}

function render() 
{
	renderer.render(scene, camera);
}

function timer(){
    if (State.inFolding){
        State.inBending = false;
        if (KState.M){
            Cursor3D.z -= 0.015;
            State.inBending = true;
            resetScene();
            display();
        }
        else if (KState.N){
            Cursor3D.z += 0.015;
            State.inBending = true;
            resetScene();
            display();
        }
        var destination = new Vector();
        destination.set (Cursor3D.x, Cursor3D.y, Cursor3D.z);
        //console.log (destination);
        Origami.moveVertex (destination, eyePosition, State.inBending);
    }
    else if (State.inAnimation){
        if (Origami.play(State.fps))
            State.inAnimation = false;

            resetScene();
            display();
    }
}

</script>

</body>
</html>